<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tutorials | Achu Wilson</title>
    <link>https://achuwilson.github.io/tags/tutorials/</link>
      <atom:link href="https://achuwilson.github.io/tags/tutorials/index.xml" rel="self" type="application/rss+xml" />
    <description>tutorials</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Â© Achu Wilson 2021</copyright><lastBuildDate>Mon, 18 Jan 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://achuwilson.github.io/img/pom-card.png</url>
      <title>tutorials</title>
      <link>https://achuwilson.github.io/tags/tutorials/</link>
    </image>
    
    <item>
      <title>A Gentle Introduction to Kuka iiwa and Drake in Python</title>
      <link>https://achuwilson.github.io/post/iiwadrake-intro/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://achuwilson.github.io/post/iiwadrake-intro/</guid>
      <description>&lt;p&gt;This document serves as a quick introduction to Kuka IIWA Robot and controlling it using Drake Python API. The examples are entirely in python and is easy to port to any other robot manipulator. Make sure you read the official Kuka documentation and is familiar with the functioning before operating the robot.&lt;/p&gt;
&lt;p&gt;The codes of the examples used in this document are available at 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/achuwilson/pydrake_iiwa&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;contents&#34;&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#kuka-system-architecture&#34;&gt;Kuka System Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#programming-the-robot&#34;&gt;Programming the Robot&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#kuka-sunrise-workbench&#34;&gt;Kuka Sunrise WorkBench&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#fri&#34;&gt;FRI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#smartpad-and-workbench-video-walk-through&#34;&gt;Smartpad and Workbench Video Walk-through&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#controlling-iiwa-from-ros&#34;&gt;Controlling IIWA from ROS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#Controlling-IIWA-from-MATLAB/Simulink/Python&#34;&gt;Controlling IIWA from MATLAB/Simulink/Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#drake&#34;&gt;Drake&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#systems&#34;&gt;Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#diagrams&#34;&gt;Diagrams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#context&#34;&gt;Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#multibodyplant&#34;&gt;MultibodyPlant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#tutorials&#34;&gt;Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#lcm&#34;&gt;LCM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#controlling-iiwa-from-drake&#34;&gt;Controlling IIWA from Drake&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#drake-iiwa-java-application&#34;&gt;Drake IIWA Java Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#kuka_driver&#34;&gt;kuka_driver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#iiwa-lcm-interface&#34;&gt;IIWA-LCM Interface&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#Controlling-Custom-Robot-from-Drake&#34;&gt;Controlling Custom Robot from Drake&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#manipulation-station&#34;&gt;Manipulation Station&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#&#34;&gt;Examples&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;#joint-control&#34;&gt;Joint Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#visualizing-the-robot-state-in-Drake-visualizers&#34;&gt;Visualizing the robot state in Drake visualizers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#Adding-an-end-effector&#34;&gt;Adding an end effector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#forward-kinematics&#34;&gt;Forward Kinematics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#inverse-inematics&#34;&gt;Inverse Kinematics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#estimating-cartesian-velocities&#34;&gt;Estimating Cartesian Velocities&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#Cartesian-velocity-control&#34;&gt;Cartesian velocity control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#estimating-cartesian-forces&#34;&gt;Estimating Cartesian forces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#hybrid-force-position-control&#34;&gt;Hybrid Force-Position control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#motion-planning-and-collision-avoidance&#34;&gt;Motion Planning and Collision Avoidance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#gravity-compensation&#34;&gt;Gravity Compensation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;#&#34;&gt;Haptic Force Feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction&#34;&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Kuka LBR IIWA is a 7 DOF collaborative robot manipulator which has got excellent torque control capabilities in addition to the common position control features. This enables capabilities like impedance control which is much beneficial when the  robot has to interact with noisy environment models, where pure position control can break things (or even the robot). The robot has joint torque sensors on all the joints. ( It should be noted that the torque estimation is not as accurate as an external Force-Torque sensor. It is observed that the error depends on robot pose and has an accuracy of approximately 5N)&lt;/p&gt;
&lt;h2 id=&#34;kuka-system-architecture&#34;&gt;&lt;strong&gt;Kuka System Architecture&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;A typical architecture of the manipulation station will be as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/architecture.jpeg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;IIWA manipulator is controlled by Kuka Sunrise Cabinet controller. It has an industrial PC running  Kuka&amp;rsquo;s version of Windows CE called Sunrise OS and a realtime OS. The sunrise OS handles the user program, GUI etc and is accessible to the user. The realtime part is hidden from the user and controls the low level hardware interfaces.&lt;/p&gt;
&lt;p&gt;The Sunrise Cabinet have multiple Ethernet interfaces. Kuka Line Interface (KLI) (Port X66) is the only one enabled by default and is used to connect the Controller to an external PC. Kuka provides Sunrise Workbench IDE with which the IIWA could be programmed in Java. The IDE also helps installing software packages and configuring settings such as network and safety configurations, input-output etc.&lt;/p&gt;
&lt;p&gt;The other interface called Fast Robot Interface (FRI) enables access to the robot controller from an external computer in real time. It operates over the Kuka Optional Network Interface (KONI) and has to be enabled by installing the FRI package. Drake uses this interface to interface with the IIWA hardware.&lt;/p&gt;
&lt;p&gt;Additional interfaces like EtherCAT, PROFINET are also available, which can be enabled by installing the corresponding software package from Kuka.&lt;/p&gt;
&lt;p&gt;Kuka Smartpad, the handheld controller allows to start and stop the programs loaded into the SunriseCabinet. In fact,  it shows the remote desktop view of the Sunrise OS running inside the Cabinet. Connecting an external monitor to the DVI port on the back side of the Sunrise Cabinet also shows the same Smartpad GUI. In addition, it is also possible to access the Smartpad GUI using Remote Desktop tools over the KLI ethernet port.&lt;/p&gt;
&lt;p&gt;The following are the default IP address of the Ethernet Ports:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    KLI :          172.31.1.147
    KONI FRI :     192.170.10.2

    Remote Desktop: 172.31.1.147
    Username:       KukaUser
    Password:       68kuka1secpw59
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following documents give a detailed overview of the Kuka IIWA Robot systems. It  is recommended to get familiarized with the IIWA system from the following documents before operating the robot.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/%f0%9f%85%b1%ef%b8%8f/g/personal/achuwilson_iisc_ac_in/EV4iYsOWqzJDo67tXQCS5RkBYui1geiQtkUp61vTxEKwrA&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KUKA Sunrise.OS 1.16, Operating Instructions for End Users&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/%f0%9f%85%b1%ef%b8%8f/g/personal/achuwilson_iisc_ac_in/Edw4l1pf6npHoR7z2O2gx-IB9v7VA7hakrdIowxQbYPMbA?e=wyLi8R&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KUKA Sunrise Cabinet Operating Instructions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/%f0%9f%85%b1%ef%b8%8f/g/personal/achuwilson_iisc_ac_in/ETb2S5FZac5DiL733qOmhicB3BOZzJFAMyjdIQaC3mI6rA?e=9Ne5Gq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;System Software KUKA Sunrise.OS 1.16, KUKA Sunrise.Workbench 1.16, Operating and Programming Instructions for System Integrators&lt;/a&gt;. This document has Java API documentation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NOTE: the linked documents could not be shared publicly as it would violate Kuka&amp;rsquo;s Copyright notice and require IISc login. You could also create a free account on 
&lt;a href=&#34;https://xpert.kuka.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuka Xpert&lt;/a&gt; to download these&lt;/p&gt;
&lt;h2 id=&#34;programming-the-robot&#34;&gt;&lt;strong&gt;Programming the Robot&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Kuka basically provides the following two methods to program the robot&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kuka Sunrise Workbench&lt;/li&gt;
&lt;li&gt;FRI&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kuka-sunrise-workbench&#34;&gt;&lt;strong&gt;Kuka Sunrise Workbench&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The default programming option provided by Kuka is through its Java APIs using Sunrise Workbench, which is in-fact a customized Eclipse IDE. It is not available for download on the Kuka website, as it has to match the version of the Sunrise OS running on the controller, So request for your copy of Sunrise Workbench to your Kuka robot supplier.&lt;/p&gt;
&lt;p&gt;The Java APIs may differ slightly depending upon the version of the Sunrise OS and Workbench that is being used. It is available in the  
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/%f0%9f%85%b1%ef%b8%8f/g/personal/achuwilson_iisc_ac_in/ETb2S5FZac5DiL733qOmhicB3BOZzJFAMyjdIQaC3mI6rA?e=9Ne5Gq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuka Sunrise Workbench Operating and Programming Instructions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After developing an application in the Sunrise Workbench, the user has to synchronize it with the Sunrise OS in the controller. This just copies the project files to the controller over the KLI port.&lt;/p&gt;
&lt;p&gt;Download Links&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/EVTSc15X_GRIlWSK5q1Tb30Bb0Yqsdy8eesSHTUHCa5uRg?e=tj55YR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuka Sunrise Workbench v1.16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/EXaiVwwBq4pKsusDc46TTOQB8VykoFdGvrw-m9PZhETiDA?e=HIVX5J&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FRI Addon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/EcM-n6luAApEnvS9MxJgs4YBfm4CiQUMdh_WkRj2hqixMQ?e=tkKpXC&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SmartServo Addon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/EY7uGq3RELJAsfiPXchYBXYBTzac1upeZKnQWZ3S3OYYxg?e=Vih3Jo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HRC Addon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/EV-CtR-rhjZLkxZBV-kK0oMBhW0X3Rcw1UlBOHzYOXZxNw?e=ddkZqd&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sample Sunrise Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://indianinstituteofscience-my.sharepoint.com/:u:/g/personal/achuwilson_iisc_ac_in/ES0_qKtT5HNLqHYRvyvdlD8BOUA83MfFFzkkU1Ie0pmPLw?e=C48Smz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FRI Client SDK C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NOTE: While creating a new project and synchronizing it with the Controller, after changing any safety related settings, the SmartPad would show a &amp;ldquo;safety configuration not activated&amp;rdquo; error. The default password to activate the safety configuration is &lt;code&gt;ARGUS&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After loading them, applications can be selected and executed using the
Smartpad interface. The Key on the Smartpad helps switch between &lt;code&gt;AUT&lt;/code&gt; - automatic and &lt;code&gt;T1&lt;/code&gt; - reduced velocity mode.&lt;/p&gt;
&lt;h3 id=&#34;fri&#34;&gt;&lt;strong&gt;FRI&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FRI stands for &amp;ldquo;Fast Robot Interface&amp;rdquo;, which is an addon provided by Kuka, enables real time control of the robot system. This requires control signals be generated in an external computer and sent over the KONI Ethernet port. The FRI is not enabled out of the box and has to be installed and enabled through the Sunrise workbench. The default IP address of the FRI interface is &lt;code&gt;192.170.10.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Kuka provides FRI-Client libraries in C++ and Java, which can be found inside the examples directory after the installation of FRI library in Sunrise WorkBench. The C++ libraries can be found in the file named &lt;code&gt;FRI-Client-SDK_Cpp.zip&lt;/code&gt;. It can be used to build applications that communicates with Kuka controller over FRI.&lt;/p&gt;
&lt;p&gt;Drake uses the FRI interface to control the IIWA from an external computer.&lt;/p&gt;
&lt;h2 id=&#34;smartpad-and-workbench-video-walk-through&#34;&gt;&lt;strong&gt;Smartpad and Workbench Video Walk-through&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;TODO #1&lt;/p&gt;
&lt;h2 id=&#34;controlling-iiwa-from-ros&#34;&gt;&lt;strong&gt;Controlling IIWA from ROS&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The 
&lt;a href=&#34;https://github.com/IFL-CAMP/iiwa_stack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_stack&lt;/code&gt;&lt;/a&gt; package can be used to interface IIWA from ROS. It uses the Smart Servoing functionality over the KLI network interface.&lt;/p&gt;
&lt;p&gt;The ROSJava nodes running on the robot controller as a Sunrise RobotApplication sends data and receives commands from a ROS master running on the external PC. The 
&lt;a href=&#34;https://github.com/IFL-CAMP/iiwa_stack/wiki&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki&lt;/a&gt; provides detailed instructions on controlling from ROS.&lt;/p&gt;
&lt;h2 id=&#34;controlling-iiwa-from-matlabsimulinkpython&#34;&gt;&lt;strong&gt;Controlling IIWA from MATLAB/Simulink/Python&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The 
&lt;a href=&#34;https://github.com/Modi1987/KST-Kuka-Sunrise-Toolbox&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kuka Sunrise Toolbox for Matlab&lt;/a&gt; allows control of the LBR iiwa robot from MATLAB.&lt;/li&gt;
&lt;li&gt;The [Simulink-iiwa interface] (&lt;a href=&#34;https://github.com/Modi1987/Simulink-iiwa-interface&#34;&gt;https://github.com/Modi1987/Simulink-iiwa-interface&lt;/a&gt;) for Simulink based control.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/Modi1987/iiwaPy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iiwaPy&lt;/a&gt; can be used for control of the iiwa from Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All of the above packages are based on the Kuka Sunrise Toolbox for Matlab.&lt;/p&gt;
&lt;h1 id=&#34;drake&#34;&gt;&lt;strong&gt;Drake&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://drake.mit.edu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Drake&lt;/a&gt; is a toolbox which can model dynamic systems, solve mathematical problems and has built in multibody kinematics and dynamics.&lt;/p&gt;
&lt;p&gt;Running the examples requires installation of Python bindings of Drake as documented 
&lt;a href=&#34;https://drake.mit.edu/python_bindings.html#python-bindings-binary&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. These were tested in Ubuntu 18.04 with binary installation of Drake.&lt;/p&gt;
&lt;h3 id=&#34;systems&#34;&gt;&lt;strong&gt;Systems&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The basic building block of Drake is a &lt;code&gt;System&lt;/code&gt;, which has input and output ports as well as an optional state. Multiple systems can be interconnected either as a &lt;code&gt;Diagram&lt;/code&gt; or &lt;code&gt;LeafSystem&lt;/code&gt;. LeafSystems are the minimum building block and is often used for basic components like sensors, actuators, controllers, planners etc, which has a specific functionality. Drake come with many built-in systems which can be found in the 
&lt;a href=&#34;https://drake.mit.edu/doxygen_cxx/group__systems.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;official documentation&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;diagrams&#34;&gt;&lt;strong&gt;Diagrams&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Diagrams consists of multiple LeafSystems or even other Diagrams inside and are used to represent a set of interconnected systems that function as a whole.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_drake_simplediagram.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_drake_simplediagram.py&lt;/code&gt;&lt;/a&gt; creates a simple diagram which looks as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/simplediagram.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The built-in &lt;code&gt;SystemSlider&lt;/code&gt; is used to create a GUI with 3 sliders, whose output is fed into a &lt;code&gt;PrintSystem&lt;/code&gt; which evaluates and prints the input values to terminal at a specific update rate.&lt;/p&gt;
&lt;h3 id=&#34;context&#34;&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;All &lt;code&gt;Diagram&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; has a &lt;code&gt;Context&lt;/code&gt; which embodies the state and parameters of the system. In addition to the &lt;code&gt;Context&lt;/code&gt; of the main diagram, each subsystems and sub diagrams have their own unique context with with we can interact with the internals of the systems. Given the &lt;code&gt;context&lt;/code&gt;, all methods called on a Diagram or System is deterministic and repeatable.  The &lt;code&gt;Simulator&lt;/code&gt; needs the &lt;code&gt;Diagram&lt;/code&gt; and its &lt;code&gt;Context&lt;/code&gt;for running the computations.&lt;/p&gt;
&lt;h3 id=&#34;multibodyplant&#34;&gt;&lt;strong&gt;MultibodyPlant&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MultibodyPlant&lt;/code&gt; is one of the most important built-in systems that Drake provides. It is used to represent multiple rigid bodies connected in tree, a common practice with serial robot manipulators. It internally uses rigid body tree algorithms to compute the kinematics. &lt;code&gt;MultibodyPlant&lt;/code&gt; also has both inputs and outputs which could be connected to other systems such as controllers or visualizers.&lt;/p&gt;
&lt;h3 id=&#34;tutorials&#34;&gt;&lt;strong&gt;Tutorials&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Drake provides a set of 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/tree/master/tutorials&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tutorials&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/tutorials/dynamical_systems.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;dynamical_systems.ipynb&lt;/code&gt;&lt;/a&gt; gives an introduction to modelling systems in Drake&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/tutorials/mathematical_program.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mathematical_program.ipynb&lt;/code&gt;&lt;/a&gt; introduces numerical programming capabilities of Drake&lt;/p&gt;
&lt;h2 id=&#34;lcm&#34;&gt;&lt;strong&gt;LCM&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://lcm-proj.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LCM&lt;/a&gt; stands for Lightweight Communications and Marshalling. It is a set of libraries that can provide publish/subscribe message passing capabilities.&lt;/p&gt;
&lt;p&gt;LCM implementatoions are available for all common programming languages and operating systems. Refer to the 
&lt;a href=&#34;https://lcm-proj.github.io/tutorial_general.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LCM example&lt;/a&gt; for a quick-start.&lt;/p&gt;
&lt;h4 id=&#34;plotting-lcm-messages&#34;&gt;&lt;strong&gt;Plotting LCM Messages&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Drake includes &lt;code&gt;drake-lcm-spy&lt;/code&gt; in &lt;code&gt;/opt/drake/bin&lt;/code&gt; to plot and visualize LCM messages.&lt;/p&gt;
&lt;h2 id=&#34;controlling-iiwa-from-drake&#34;&gt;&lt;strong&gt;Controlling IIWA from Drake&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The following diagram shows a typical architecture of a Drake based system for controlling the iiwa.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/drake_arch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DrakeFRIPositionDriver&lt;/code&gt;  and &lt;code&gt;DrakeFRITorqueDriver&lt;/code&gt; are Java applications built using the Sunrise Workbench and running inside the Sunrise Controller. They open an FRI connection at a specified network port, to which an external computer can connect to.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kuka_driver&lt;/code&gt; is a C++ application built using the FRI-Client-SDK-Cpp and runs on the external computer. It communicates with the Sunrise Controller over the FRI/KONI interface. It also publishes and subscribes LCM messages which can be used by other programs to read/write data to the iiwa robot.&lt;/p&gt;
&lt;p&gt;Drake has a built in &lt;code&gt;LCMInterfaceSystem&lt;/code&gt; which allows drake systems to publish and subscribe to LCM messages. Other Drake systems make use of these systems to communicate with the hardware.&lt;/p&gt;
&lt;h3 id=&#34;drake-iiwa-java-application&#34;&gt;&lt;strong&gt;Drake IIWA Java Application&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The Java application runs on the on the Sunrise Controller and opens an FRI connection to which the &lt;code&gt;kuka_driver&lt;/code&gt; running on an external computer connects to.&lt;/p&gt;
&lt;p&gt;The detailed documentation and code is available in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake-iiwa-driver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;drake-iiwa-driver&lt;/code&gt;&lt;/a&gt;
There are two applications&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DrakeFRIPositionDriver&lt;/li&gt;
&lt;li&gt;DrakeFRITorqueDriver&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The DrakeFRIPositionDriver, as the name  implies allows controlling the robot in position control mode, taking in joint position commands.&lt;/p&gt;
&lt;p&gt;The DrakeFRITorqueDriver allows for the control of the robot in impedance control mode and takes in joint position as well as joint feed-forward torque commands. We would be using this mode more often.&lt;/p&gt;
&lt;p&gt;Both the drivers output robot status like joint positions, velocities, torques etc&lt;/p&gt;
&lt;h3 id=&#34;kuka_driver&#34;&gt;&lt;strong&gt;kuka_driver&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;kuka_driver&lt;/code&gt; runs on the external computer, connects to the Java application running on the robot and provides an LCM interface to read/write data.&lt;/p&gt;
&lt;p&gt;It has to be compiled as in this 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake-iiwa-driver/blob/master/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;documentation&lt;/a&gt; and requires FRI client SDK for compilation.&lt;/p&gt;
&lt;p&gt;After compilation, the &lt;code&gt;kuka_driver&lt;/code&gt; should be run first, so as to communicate with IIWA&lt;/p&gt;
&lt;h3 id=&#34;iiwa-lcm-interface&#34;&gt;&lt;strong&gt;IIWA-LCM Interface&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;kuka_driver&lt;/code&gt; provides read/write interface to the IIWA through LCM messages. It generates three LCM message channels&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IIWA_STATUS&lt;/code&gt; of the type &lt;code&gt;lcmt_iiwa_status&lt;/code&gt;, defined in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/lcmtypes/lcmt_iiwa_status.lcm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcmt_iiwa_status.lcm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIWA_COMMAND&lt;/code&gt; of the type &lt;code&gt;lcmt_iiwa_command&lt;/code&gt;, defined in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/lcmtypes/lcmt_iiwa_command.lcm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcmt_iiwa_command.lcm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIWA_STATUS_TELEMETRY&lt;/code&gt; of the type &lt;code&gt;lcmt_iiwa_status_telemetry&lt;/code&gt;, defined in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/lcmtypes/lcmt_iiwa_status_telemetry.lcm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcmt_iiwa_status_telemetry.lcm&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By default, &lt;code&gt;kuka_driver&lt;/code&gt; publishes/ subscribes these messages at 200Hz&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IIWA_STATUS&lt;/code&gt; provides the robot joint status which includes joint position, velocities and torques. An example which subscribes to the &lt;code&gt;IIWA_STATUS&lt;/code&gt; and prints the output is available in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/lcm_examples/iiwa-lcm-listener.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcm_examples/iiwa-lcm-listener.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IIWA_COMMAND&lt;/code&gt; is used to command joint positions with an optional feed forward joint torque. An example which subscribes to &lt;code&gt;IIWA_STATUS&lt;/code&gt; to estimate the current robot configuration and move joint 7 incrementally is available in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/lcm_examples/iiwa-lcm-publisher.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcm_examples/iiwa-lcm-publisher.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IIWA_STATUS_TELEMETRY&lt;/code&gt; provides timing information, which can be used to estimate the latency in the FRI communication between the external computer and the robot controller.&lt;/p&gt;
&lt;h2 id=&#34;controlling-custom-robot-from-drake&#34;&gt;&lt;strong&gt;Controlling Custom Robot from Drake&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The Kuka iiwa interface in this documentation can be adapted to interface custom robot manipulators. Following would be the minimum requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a hardware interface program similar to &lt;code&gt;kuka_driver&lt;/code&gt;, which reads and writes from the hardware. As a bare minimum, we should be able to write joint positions and read joint positions from the hardware and pass it on as LCM messages.&lt;/li&gt;
&lt;li&gt;Define custom LCM messages depending on the hardware capabilities. Take a look at 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/lcmtypes/lcmt_iiwa_command.lcm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcmt_iiwa_command.lcm&lt;/code&gt;&lt;/a&gt; and 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/lcmtypes/lcmt_iiwa_status.lcm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;lcmt_iiwa_status.lcm&lt;/code&gt;&lt;/a&gt; and others defined in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/tree/master/lcmtypes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;lcmtypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Develop Drake systems that parses the custom LCM messages and interfaces them to other Drake systems, similar to 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/iiwa_command_sender.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_status_receiver.py&lt;/code&gt;&lt;/a&gt; and 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/iiwa_command_sender.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_command_sender.py&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;URDF/SDF model of the robot. This will be used to create the MultibodyPlant which is used to compute the kinematics and dynamics of the system. (NOTE: use OBJ files instead of STL/DAE)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;manipulation-station&#34;&gt;&lt;strong&gt;Manipulation Station&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;The manipulation station consists of the IIWA robot, the Drake systems required to communicate and parse the data with the IIWA as well as other optional hardware such as cameras, grippers etc&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IiwaManipulationStation&lt;/code&gt;, defined in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/iiwa_manipulation_station.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_manipulation_station.py&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;Diagram&lt;/code&gt; which has to be included and initialized in the diagram created by the user, so as to communicate with the IIWA. It consists of the following systems:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - LcmInterfaceSystem
    - LcmSubscriberSystem
    - LcmPublisherSystem
    - IiwaCommandSender
    - IiwaStatusReceiver
    - MultibodyPlant
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The diagram of the manipulation system looks as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/manipulation_station.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;LcmInterfaceSystem&lt;/code&gt; has no inputs nor outputs nor state nor parameters; it declares only an update event that pumps LCM messages into their subscribers if the LCM stack has message(s) waiting. The subscribers will then update their outputs using their own declared events&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;LcmSubscriberSystem&lt;/code&gt; subscribes to the LCM data stream and outputs the received data through a single output port.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;LCMPublisherSystem&lt;/code&gt; has a single input port and outputs the received data to the LCM data stream at a specified update rate.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IiwaStatusReceiver&lt;/code&gt;, defined in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/iiwa_status_receiver.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_status_receiver.py&lt;/code&gt;&lt;/a&gt; parses the &lt;code&gt;IIWA_STATUS&lt;/code&gt; LCM  message into the following vector valued outputs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - position_commanded
    - position_measured
    - velocity_estimated
    - torque_commanded
    - torque_measured
    - torque_external
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example on using &lt;code&gt;IiwaStatusReceiver&lt;/code&gt; is available in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_iiwa_status_receiver.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_iiwa_status_receiver.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;IiwaCommandSender&lt;/code&gt;,  defined in  
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/iiwa_command_sender.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;iiwa_command_sender.py&lt;/code&gt;&lt;/a&gt; encodes the input into &lt;code&gt;IIWA_COMMAND&lt;/code&gt; LCM message which is published by the &lt;code&gt;LcmSubscriberSystem&lt;/code&gt;. It has the following two vector valued inputs accepting vectors of size 7.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    - position
    - torque
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example usage of &lt;code&gt;IiwaCommandSender&lt;/code&gt; is available in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_iiwa_command_sender.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_iiwa_command_sender.py&lt;/code&gt;&lt;/a&gt;. Be EXTREMELY CAUTIOUS  before running this example, as it would instantaneously command 0 positions to joints. Don&amp;rsquo;t run this example unless all joints are near to zero position.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;MultibodyPlant&lt;/code&gt; models the external plant that has to be controlled and helps in the computation of its kinematics and dynamics.&lt;/p&gt;
&lt;p&gt;The input and output ports of the individual systems inside inside a diagram has to be exported to outside so that other drake systems can interface with the inner systems. The &lt;code&gt;ExportOutput&lt;/code&gt; and &lt;code&gt;ExportInput&lt;/code&gt; methods of &lt;code&gt;DiagramBuilder&lt;/code&gt; are used for this.&lt;/p&gt;
&lt;h1 id=&#34;examples&#34;&gt;&lt;strong&gt;Examples&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;The codes of the examples used in this document are available at 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/achuwilson/pydrake_iiwa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To run the examples, follow these steps&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STEP1: Make sure that the Kuka is in &lt;code&gt;AUT &lt;/code&gt; mode in SmartPad&lt;/li&gt;
&lt;li&gt;STEP2: Select and run &lt;code&gt;DrakeFRITorqueDriver&lt;/code&gt; Application from the Smartpad&lt;/li&gt;
&lt;li&gt;STEP3: run &lt;code&gt;kuka_driver&lt;/code&gt;  in the PC. This will cause the brakes on IIWA to release&lt;/li&gt;
&lt;li&gt;STEP4: (optional) Start &lt;code&gt;drake-visualizer&lt;/code&gt; or &lt;code&gt;meshcat-server&lt;/code&gt; for examples requiring visualization&lt;/li&gt;
&lt;li&gt;STEP4: run the example&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;joint-control&#34;&gt;&lt;strong&gt;Joint Control&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_joint_slider.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_joint_slider.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this simple example, we make use of the drake &lt;code&gt;JointSliders&lt;/code&gt; system to control the joint values of the robot.
The system diagram of the example is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/jointcontrol.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The output port of the &lt;code&gt;JointSliders&lt;/code&gt; system is connected through a &lt;code&gt;FirstOrderLowPassFilter&lt;/code&gt; to the &lt;code&gt;iiwa_position&lt;/code&gt; port of the &lt;code&gt;IiwaHardwareInterface&lt;/code&gt; manipulation station. The &lt;code&gt;FirstOrderLowPassFilter&lt;/code&gt; helps to smoothen the motion by filtering out high frequency changes in position which may cause jerk.&lt;/p&gt;
&lt;h2 id=&#34;visualizing-the-robot-state-in-drake-visualizers&#34;&gt;&lt;strong&gt;Visualizing the robot state in Drake visualizers&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_iiwa_visualize.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_iiwa_visualize.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Drake has multiple visualizers and uses the SceneGraph system to output the visualizations. By default, Drake comes with a VTK based visualizer which is located in &lt;code&gt;/opt/drake/bin/drake-visualizer&lt;/code&gt;. We have to launch the visualizer before running the simulation.&lt;/p&gt;
&lt;p&gt;Drake also has a Meshcat based visualizer which can display the output in a browser window. Run &lt;code&gt;meshcat-server&lt;/code&gt; present in the same directory. Meshcat visualizer is greatly helpful when running Drake as IPython notebooks in Google Colab&lt;/p&gt;
&lt;p&gt;The system diagram of the example is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/visualize_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_iiwa_visualize.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_iiwa_visualize.py&lt;/code&gt;&lt;/a&gt; example,  the &lt;code&gt;MultibodyPositionToGeometryPose&lt;/code&gt; system takes in the joint positions of the robot and outputs the pose output required by the &lt;code&gt;SceneGraph&lt;/code&gt; system. The &lt;code&gt;DrakeVisualizer&lt;/code&gt; and &lt;code&gt;meshcat_visualizer&lt;/code&gt; queries the scenegraph system and updates the rendering.&lt;/p&gt;
&lt;p&gt;The DrakeVisualizer looks as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/drake-visualizer.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;adding-an-end-effector&#34;&gt;&lt;strong&gt;Adding an end effector&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_iiwa_endeffector.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_iiwa_endeffector.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This example demonstrates how to add a custom end-effector/gripper to the &lt;code&gt;IiwaManipulationStation&lt;/code&gt;. End effector models, either in URDF or SDF format could be imported and added to the &lt;code&gt;MultibodyPlant&lt;/code&gt; before finalizing it. It also needs to be welded to the last link of IIWA.&lt;/p&gt;
&lt;p&gt;Following image shows IIWA attached with the small blue finger defined in 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/models/onefinger.urdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;models/onefinger.urdf&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/endeffector.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Once the end-effector is added to the MultibodyPlant, we can refer to it by the name defined in the URDF file.&lt;/p&gt;
&lt;h2 id=&#34;forward-kinematics&#34;&gt;&lt;strong&gt;Forward Kinematics&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_FK.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_FK.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Forward Kinematics calculates the position of end effector/gripper in the world given the joint position values.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/fk_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In this example, the low pass filtered values from the slider is used to set the joint positions of the IIWA hardware. The &lt;code&gt;iiwa_position_measured&lt;/code&gt; output port of the manipulation station is connected to the &lt;code&gt;FKSystem&lt;/code&gt;, where the joint values of the multibodyplant are updated. The &lt;code&gt;EvalBodyPoseInWorld&lt;/code&gt; function can be used to evaluate the position of the body in the world.&lt;/p&gt;
&lt;h2 id=&#34;inverse-kinematics&#34;&gt;&lt;strong&gt;Inverse Kinematics&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_IK.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_IK.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Inverse Kinematics solves for the joint positions required to reach a particular end-effector pose.&lt;/p&gt;
&lt;p&gt;Drake has a numeric 
&lt;a href=&#34;https://drake.mit.edu/doxygen_cxx/classdrake_1_1multibody_1_1_inverse_kinematics.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;InverseKinematics&lt;/a&gt; solver which  formulates IK as a nonlinear optimization problem. We can specify non linear inequality constraints like minimum distance between bodies, position/orientation constraints, target gaze constraints etc.
Refer to 
&lt;a href=&#34;https://www.youtube.com/watch?v=RjKkA_6-0C4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT 6.881 Lecture 15, Motion Planning, Part 1&lt;/a&gt; for more insights on Inverse kinematics and declaring constraints. Corresponding 
&lt;a href=&#34;https://github.com/RussTedrake/manipulation/blob/master/trajectories.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IPython Notebook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Drake also has a 
&lt;a href=&#34;https://drake.mit.edu/doxygen_cxx/namespacedrake_1_1manipulation_1_1planner.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Differential Inverse Kinematics solver&lt;/a&gt;, which calculates joint velocities using Jacobian and integrates it to calculate the joint position. The 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_IK.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_IK.py&lt;/code&gt;&lt;/a&gt; uses the differential IK method implemented in 
&lt;a href=&#34;https://github.com/RobotLocomotion/drake/blob/master/examples/manipulation_station/differential_ik.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;differential_ik.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The system diagram of the 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_IK.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_IK.py&lt;/code&gt;&lt;/a&gt; is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/ik_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;estimating-cartesian-velocities&#34;&gt;&lt;strong&gt;Estimating Cartesian Velocities&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_velocity_estimate.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_velocity_estimate.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;End effector velocities can be estimated by multiplying the robot Jacobian with joint velocities. Drake &lt;code&gt;MultibodyPlant&lt;/code&gt; has the &lt;code&gt;CalcJacobianSpatialVelocity&lt;/code&gt; method, which could be used to calculate the Spatial Jacobian.&lt;/p&gt;
&lt;p&gt;The system diagram of the example is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/vel_est_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;In 
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_velocity_estimate.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_velocity_estimate.py&lt;/code&gt;&lt;/a&gt;, The output of &lt;code&gt;EndEffectorTeleop&lt;/code&gt; is used to control the cartesian end effector position through the &lt;code&gt;DifferentialIK&lt;/code&gt; system. The &lt;code&gt;iiwa_velocity_estimated&lt;/code&gt; and &lt;code&gt;iiwa_position_measured&lt;/code&gt; outputs of the manipulation station are used by the  &lt;code&gt;velocityEstimator&lt;/code&gt; system to calculate the Jacobian and corresponding  end effector velocities.&lt;/p&gt;
&lt;h2 id=&#34;cartesian-velocity-control&#34;&gt;&lt;strong&gt;Cartesian velocity control&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_velocity_control.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_velocity_control.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WARNING: Pay close attention when running this example on the real robot. The end effector keeps on moving at the commanded velocity, until the slider is moved back to zero.&lt;/p&gt;
&lt;p&gt;Joint velocities required to move the end effector at a desired velocity in cartesian space are computed using an inverse Jacobian controller.&lt;/p&gt;
&lt;p&gt;The system diagram is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/vel_ctrl_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The desired end effector velocity from the slider and the current joint position is fed as inputs to the  &lt;code&gt;PseudoInverseVelocityController&lt;/code&gt;. It calculates the required joint velocities, which are integrated and fed as &lt;code&gt;iiwa_position&lt;/code&gt; input.&lt;/p&gt;
&lt;h2 id=&#34;estimating-cartesian-forces&#34;&gt;&lt;strong&gt;Estimating Cartesian forces&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_force_estimate.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_force_estimate.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IIWA has joint torque sensors at all the 7 joints. This example uses jacobian transpose to estimate the forces and in cartesian space at the end effector from the measured joint torques.&lt;/p&gt;
&lt;p&gt;The system diagram of the example is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/force_est_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;It looks similar to the velocity estimation system, except that in this case, there is a &lt;code&gt;forceEstimator&lt;/code&gt; system that takes in &lt;code&gt;iiwa_position_measured&lt;/code&gt; and &lt;code&gt;iiwa_torque_external&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;hybrid-force-position-control&#34;&gt;&lt;strong&gt;Hybrid Force-Position control&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/achuwilson/pydrake_iiwa/blob/main/example_force_feedforward.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example_force_feedforward.py&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In Hybrid force-position demo, the end effector is able to move to/maintain a position as well exert force in arbitrary directions.&lt;/p&gt;
&lt;p&gt;We make use of the &lt;code&gt;iiwa_feedforward_torque&lt;/code&gt; input to provide additional joint torques. These torques are calculated using Jacobian transpose pseudo-inverse in the &lt;code&gt;FeedForwardForceController&lt;/code&gt; system. while running the demo, two windows will pop up, one for controlling the cartesian position and the other for the cartesian wrench.&lt;/p&gt;
&lt;p&gt;The system diagram of the example is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/force_ctrl_system.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;motion-planning-and-collision-avoidance&#34;&gt;&lt;strong&gt;Motion Planning and Collision Avoidance&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;TODO #2&lt;/p&gt;
&lt;h2 id=&#34;gravity-compensation&#34;&gt;&lt;strong&gt;Gravity Compensation&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;TODO #3&lt;/p&gt;
&lt;h2 id=&#34;haptic-force-feedback&#34;&gt;&lt;strong&gt;Haptic Force Feedback&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;TODO #4&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
